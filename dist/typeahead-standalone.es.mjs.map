{"version":3,"file":"typeahead-standalone.es.mjs","sources":["../src/helpers.ts","../src/fetchWrapper/fetchWrapper.ts","../src/trie/trie.ts","../src/typeahead-standalone.ts"],"sourcesContent":["import type { Dictionary } from './common.d.ts';\n\nexport const NOOP = (...args: unknown[]): void => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: unknown): item is Dictionary => {\n  return item !== null && (item as Dictionary)?.constructor.name === 'Object';\n};\n\nexport const isString = (item: unknown): item is string => typeof item === 'string';\n\nexport const getNestedValue = (obj: unknown, selector: string): string => {\n  let ref: any = obj;\n  const keys = selector.split('.');\n\n  for (const key of keys) {\n    if (!isObject(ref) || !(key in ref)) {\n      return '';\n    }\n    ref = ref[key];\n  }\n\n  return `${ref}`;\n};\n\n/** @deprecated */\nexport const deduplicateArr = (iterable: Dictionary[], prop: string): Dictionary[] => [\n  ...new Map(iterable.map((item) => [item[prop], item])).values(),\n];\n\nexport const diacritics = (txt = '') => txt.normalize('NFD').replace(/\\p{Diacritic}/gu, '');\n\n/****** helpers specific to typeahead  *****/\n\nexport const normalizer = <T extends Dictionary>(listItems: string[] | Dictionary[] | T[], key: string): T[] => {\n  if (!listItems.length) return [];\n\n  // validate array of objects\n  if (isObject(listItems[0])) {\n    // verify if key exists (i.e. normalized already)\n    for (const item of listItems) {\n      if (!getNestedValue(item, key)) {\n        throw new Error('e03');\n      }\n    }\n\n    return listItems as T[];\n  }\n\n  // normalize array of strings\n  return (listItems as string[]).map((item) => ({\n    [key]: isString(item) ? item : JSON.stringify(item),\n  })) as T[];\n};\n\n/****** helpers specific to Trie  *****/\n\nexport const spaceTokenizer = (tokenString: string): string[] => tokenString.split(/\\s+/);\n","// A custom FETCH API wrapper\n// inspired by https://jasonwatmore.com/post/2020/04/18/fetch-a-lightweight-fetch-wrapper-to-simplify-http-requests\n\nconst get = async function (url: RequestInfo | URL, requestOptions?: RequestInit): Promise<any> {\n  const response = await fetch(\n    url,\n    requestOptions || {\n      method: 'GET',\n    }\n  );\n  return handleResponse(response);\n};\n\n// helper function\nconst handleResponse = async function (response: Response) {\n  const text = await response.text();\n  const data = text && JSON.parse(text);\n  if (!response.ok) {\n    return Promise.reject((data && data.message) || response.statusText);\n  }\n  return data;\n};\n\nexport const fetchWrapper = {\n  get,\n};\n\n/*\n * @deprecated: Post method not required at the moment\n */\n// const post = async function (url: string, body: unknown): Promise<any> {\n//   const requestOptions = {\n//     method: 'POST',\n//     headers: { 'Content-Type': 'application/json' },\n//     body: JSON.stringify(body),\n//   };\n//   const response = await fetch(url, requestOptions);\n//   return handleResponse(response);\n// };\n","import type { Dictionary } from '../common.d.ts';\nimport type { SearchResults, TrieType } from './types.d.ts';\nimport { spaceTokenizer, diacritics, getNestedValue, isString } from '../helpers.js';\n\n// Trie algorithm (inspired by data structures @https://github.com/Yomguithereal/mnemonist)\nexport const Trie: TrieType<any> = (config = {}) => {\n  const { hasDiacritics, tokenizer } = config;\n  let root: Record<string, unknown> = {};\n\n  // marks the end of a string\n  const SENTINEL = String.fromCharCode(0);\n\n  /**\n   * Returns data/query tokens\n   */\n  function tokenize(value = '') {\n    value = `${value}`.trim(); // coerce to string and trim\n\n    if (hasDiacritics) {\n      value = diacritics(value);\n    }\n    // make search case insensitive\n    return (tokenizer || spaceTokenizer)(value.toLowerCase());\n  }\n\n  /**\n   * Method used to add the given data to the trie.\n   * key is optional when data is a string|string[], but mandatory for Dictionary[]\n   */\n  function add(data: string | string[] | Dictionary[], key = '', identity?: (item?: unknown) => string): void {\n    if (!data) return;\n\n    let node: Record<string, unknown>;\n    data = Array.isArray(data) ? data : [data];\n    const isStringArr = isString(data[0]);\n\n    for (const value of data) {\n      // we tokenize the incoming data to make search possible by fragments\n      const dataTokens = tokenize(isStringArr ? (value as string) : getNestedValue(value, key));\n      for (const prefix of dataTokens) {\n        if (!prefix) continue; // filter out falsy values\n\n        node = root;\n\n        for (const char of prefix) {\n          node = (node[char] ||= {}) as Record<string, unknown>;\n        }\n\n        const uniqueId = isStringArr ? value : (identity && identity(value)) || JSON.stringify(value);\n        const sentinelNode = (node[SENTINEL] ??= {});\n        (sentinelNode as Dictionary)[uniqueId as string] = value;\n      }\n    }\n  }\n\n  /**\n   * Internal Method used to retrieve items in the trie beginning with the given prefix.\n   */\n  function find(prefix: string): Dictionary {\n    let node = root;\n    let matches: Dictionary = {};\n\n    // traverse the root until you reach the end of prefix\n    for (const char of prefix) {\n      node = node?.[char] as Record<string, unknown>;\n      if (typeof node === 'undefined') return {};\n    }\n\n    // Performing DFS (Depth-First Search) from prefix to traverse the tree\n    const stack = [{ node, prefix }];\n\n    while (stack.length) {\n      const { node, prefix } = stack.pop() as { node: Record<string, unknown>; prefix: string };\n\n      for (const k in node) {\n        if (k === SENTINEL) {\n          // Object.assign(matches, node[SENTINEL]);\n          const results = node[SENTINEL] as Dictionary;\n          for (const resultKey in results) {\n            matches[resultKey] = results[resultKey];\n          }\n        } else {\n          stack.push({ node: node[k] as Record<string, unknown>, prefix: prefix + k });\n        }\n      }\n    }\n\n    return matches as Dictionary;\n  }\n\n  // Returns the intersection of two dictionaries\n  const intersectDictionaries = (dict1: Dictionary, dict2: Dictionary): Dictionary => {\n    const result: Dictionary = {};\n    for (const key in dict1) {\n      if (key in dict2) {\n        result[key] = dict1[key];\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Search for query strings within the trie\n   */\n  function search(query: string, limit?: number): SearchResults<Dictionary | string> {\n    const queryTokens = tokenize(query);\n\n    // limit input queries to 20 tokens/words for improved performance\n    const queryTokenLimit = queryTokens.length <= 20 ? queryTokens.length : 20;\n\n    // Search for multiple tokens/queries and get initial matches\n    let suggestions: Dictionary | Dictionary[] = find(queryTokens[0]);\n\n    for (let i = 1; i < queryTokenLimit; i++) {\n      suggestions = intersectDictionaries(suggestions, find(queryTokens[i])); // get intersection of found suggestions\n      if (!Object.keys(suggestions).length) break; // exit if no matches are found\n    }\n\n    suggestions = Object.values(suggestions) as Dictionary[];\n\n    const count = suggestions.length;\n\n    // truncate suggestions to limit\n    if (limit && count > limit) {\n      suggestions.length = limit;\n    }\n\n    return {\n      suggestions,\n      count,\n    };\n  }\n\n  function clear() {\n    root = {};\n  }\n\n  return {\n    add,\n    clear,\n    search,\n  };\n};\n","/*\n * https://github.com/digitalfortress-tech/typeahead-standalone\n * Copyright (c) 2020 Niket Pathak\n * MIT License\n */\n\nimport type {\n  typeaheadResult,\n  typeaheadConfig,\n  typeaheadHtmlTemplates,\n  Dictionary,\n  LocalDataSource,\n  RemoteDataSource,\n  PrefetchDataSource,\n  ResultSet,\n  typeaheadStyleClasses,\n} from './common.d.ts';\nimport { diacritics, escapeRegExp, getNestedValue, isObject, NOOP, normalizer, spaceTokenizer } from './helpers.js';\nimport { fetchWrapper } from './fetchWrapper/fetchWrapper.js';\nimport { Trie } from './trie/trie.js';\nimport './style.less';\n\nconst typeahead = <T extends Dictionary>(config: typeaheadConfig<T>): typeaheadResult<T> => {\n  // check required params\n  if (!config.input) throw new Error('e01');\n  if (!isObject(config.source)) throw new Error('e02');\n\n  const listContainer: HTMLDivElement = document.createElement('div');\n  const preventSubmit = config.preventSubmit || false;\n  const minLen = config.minLength || 1;\n  const hint = config.hint === false ? false : true;\n  const autoSelect = config.autoSelect || false;\n  const tokenizer = config.tokenizer || spaceTokenizer;\n  const templates: typeaheadHtmlTemplates<T> | undefined = config.templates;\n  const keys = Array.isArray(config.source.keys) ? config.source.keys : ['label']; // \"label\" is the default key\n  const groupKey = config.source.groupKey || '';\n  const displayCb = <T extends Dictionary>(item: T): string => getNestedValue(item, keys[0]);\n  const display: (item: T, e?: MouseEvent | KeyboardEvent | null) => string = config.display || displayCb;\n  const identity = config.source.identity || displayCb;\n  const onSubmit: (e: Event, item?: T) => void = config.onSubmit || NOOP;\n  const transform = config.source.transform || ((data) => data);\n  const local = (config.source as LocalDataSource<T>).local || null;\n  const remoteUrlType = typeof (config.source as RemoteDataSource<T>).remote?.url;\n  const remote =\n    remoteUrlType === 'function' ||\n    (remoteUrlType === 'string' && (config.source as RemoteDataSource<T>).remote.wildcard)\n      ? (config.source as RemoteDataSource<T>).remote\n      : null;\n  const prefetch = (config.source as PrefetchDataSource<T>).prefetch?.url\n    ? { ...{ when: 'onInit', done: false }, ...(config.source as PrefetchDataSource<T>).prefetch }\n    : null;\n  const classNames: typeaheadStyleClasses = {\n    wrapper: 'typeahead-standalone',\n    input: 'tt-input',\n    hint: 'tt-hint',\n    highlight: 'tt-highlight',\n    hide: 'tt-hide',\n    show: 'tt-show',\n    list: 'tt-list',\n    selected: 'tt-selected',\n    header: 'tt-header',\n    footer: 'tt-footer',\n    loader: 'tt-loader',\n    suggestion: 'tt-suggestion',\n    group: 'tt-group',\n    empty: 'tt-empty',\n    notFound: 'tt-notFound',\n    ...(config.classNames || {}),\n  };\n\n  // validate presence of atleast one data-source\n  if (!local && !prefetch && !remote) throw new Error('e02');\n\n  // initialise trie if atleast 1 source exists\n  const trie = Trie({ hasDiacritics: config.diacritics, tokenizer });\n\n  // Main Wrapper/container element\n  const wrapper: HTMLDivElement = document.createElement('div');\n  wrapper.className = classNames.wrapper;\n\n  const resultSet: ResultSet<T> = {\n    query: '',\n    hits: [], // suggestions\n    count: 0,\n    limit: config.limit || 5,\n    wrapper,\n  };\n\n  let remoteQueryCache: Dictionary = {};\n  let remoteResponseCache: Dictionary = {};\n\n  let selected: T | undefined;\n  let remoteDebounceTimer: NodeJS.Timeout;\n  let fetchInProgress = false;\n  let storedInput = ''; // used only for keyboard navigation\n\n  // init templates if they exist\n  if (templates) {\n    templates.header = typeof templates.header === 'function' ? templates.header : undefined;\n    templates.footer = typeof templates.footer === 'function' ? templates.footer : undefined;\n    templates.notFound = typeof templates.notFound === 'function' ? templates.notFound : undefined;\n    templates.group = typeof templates.group === 'function' ? templates.group : undefined;\n    templates.suggestion = typeof templates.suggestion === 'function' ? templates.suggestion : undefined;\n    templates.loader = typeof templates.loader === 'function' ? templates.loader : undefined;\n    templates.empty = typeof templates.empty === 'function' ? templates.empty : undefined;\n  }\n\n  const addToIndex = (suggestions: string[] | Dictionary[] | T[] = []) => {\n    updateSearchIndex(normalizer(suggestions, keys[0]) as T[]);\n  };\n\n  // if local source exists, add the suggestions to the index\n  local && addToIndex(local);\n\n  const input: HTMLInputElement = config.input;\n  input.classList.add(classNames.input);\n  const computedInputStyle = window.getComputedStyle(input);\n\n  // move input element into the wrapper element\n  const parentEl = input.parentNode as HTMLElement;\n  const inputIndex = [...parentEl.children].indexOf(input);\n  parentEl.removeChild(input);\n  wrapper.appendChild(input);\n\n  // append Wrapper element to the original parent\n  parentEl.insertBefore(wrapper, parentEl.children[inputIndex]);\n\n  // generate markup for hints\n  const inputHint: HTMLInputElement = input.cloneNode() as HTMLInputElement;\n  hint && injectHintEl(inputHint);\n\n  listContainer.classList.add(classNames.list, classNames.hide);\n  listContainer.setAttribute('aria-label', 'menu-options');\n  listContainer.setAttribute('role', 'listbox');\n\n  // set listContainer positioning\n  listContainer.style.position = 'absolute'; // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n  listContainer.style.width = `${input.offsetWidth}px`;\n  listContainer.style.marginTop = `${input.offsetHeight + parseInt(computedInputStyle.marginTop)}px`;\n\n  // Attach list container\n  wrapper.appendChild(listContainer);\n\n  if (prefetch && prefetch.when === 'onInit') {\n    prefetchData();\n  }\n\n  function prefetchData() {\n    // check if data was already prefetched for current session\n    if (!prefetch || prefetch.done) return;\n\n    let transformed: T[] = [];\n\n    fetchWrapper\n      .get(typeof prefetch.url === 'function' ? prefetch.url() : prefetch.url, prefetch?.requestOptions)\n      .then(\n        (data) => {\n          transformed = transform(data) as T[];\n          transformed = normalizer(transformed, keys[0]) as T[];\n          updateSearchIndex(transformed);\n        },\n        (reject) => {\n          console.error('e04', reject);\n        }\n      )\n      .finally(() => {\n        typeof prefetch.process === 'function' && prefetch.process(transformed);\n      });\n\n    prefetch.done = true;\n  }\n\n  /**\n   * Display/show the listContainer\n   */\n  const show = (): void => {\n    listContainer.classList.remove(classNames.hide);\n  };\n\n  /**\n   * Hides the listContainer from DOM\n   */\n  const hide = (): void => {\n    listContainer.classList.add(classNames.hide);\n  };\n\n  /**\n   * Flag to indicate if the list of suggestions is open or not\n   * @returns Boolean\n   */\n  const isListOpen = (): boolean => !listContainer.classList.contains(classNames.hide);\n\n  /**\n   * Clear remote debounce timer if assigned\n   */\n  const clearRemoteDebounceTimer = (): void => remoteDebounceTimer && clearTimeout(remoteDebounceTimer);\n\n  /**\n   * Clear typeahead state and hide listContainer\n   */\n  const clear = (): void => {\n    resultSet.hits = [];\n    inputHint.value = '';\n    storedInput = '';\n    hide();\n  };\n\n  /*\n   * Triggers a user input event\n   */\n  const emitInputEvent = (): void => {\n    input.dispatchEvent(\n      new InputEvent('input', {\n        bubbles: true,\n        inputType: 'insertCompositionText',\n        data: input.value,\n      })\n    );\n  };\n\n  /**\n   * Displays the NotFound template if it exists, otherwise, does nothing (i.e. returns true)\n   * @param asyncRender set to true for asyncRenders\n   * @returns true if no suggestions are found, else returns undefined\n   */\n  const noSuggestionsHandler = (asyncRender = false) => {\n    if (!resultSet.hits.length && resultSet.query) {\n      // clear the list and the DOM\n      clear();\n      clearListDOM();\n\n      const notFoundTemplateHtml = templates?.notFound?.(resultSet);\n      if (!notFoundTemplateHtml) return true;\n\n      const renderNotFoundTemplate = (html: string) => {\n        const notFoundEl = document.createElement('div');\n        notFoundEl.classList.add(classNames.notFound);\n        templatify(notFoundEl, html);\n        listContainer.appendChild(notFoundEl);\n      };\n\n      if (!remote) {\n        renderNotFoundTemplate(notFoundTemplateHtml);\n      } else if (remoteQueryCache[JSON.stringify(resultSet.query)] || (asyncRender && !fetchInProgress)) {\n        // wait for remote results before rendering notFoundTemplate / render immediately if request was cached\n        renderNotFoundTemplate(notFoundTemplateHtml);\n      }\n\n      show();\n      return true;\n    }\n  };\n\n  /**\n   * Delete all children from typeahead DOM listContainer\n   */\n  const clearListDOM = () => {\n    while (listContainer.firstChild) {\n      listContainer.firstChild.remove();\n    }\n  };\n\n  const loader = () => {\n    if (!templates?.loader) {\n      return;\n    }\n\n    if (!fetchInProgress) {\n      const loaderEl = listContainer.querySelector(`.${classNames.loader}`);\n      loaderEl && listContainer.removeChild(loaderEl);\n      return;\n    }\n\n    // display spinner/loader\n    const loaderDiv = document.createElement('div');\n    loaderDiv.classList.add(classNames.loader);\n    templatify(loaderDiv, templates.loader());\n    if (templates?.footer) {\n      listContainer.insertBefore(loaderDiv, listContainer.querySelector(`.${classNames.footer}`));\n    } else {\n      listContainer.appendChild(loaderDiv);\n    }\n  };\n\n  /**\n   * Responsible for drawing/updating the view\n   */\n  const update = (): void => {\n    // No Matches\n    if (noSuggestionsHandler()) return;\n\n    clearListDOM();\n\n    // function for rendering typeahead suggestions\n    const render = (item: T): HTMLDivElement => {\n      const itemElement = document.createElement('div');\n      itemElement.classList.add(classNames.suggestion);\n      itemElement.setAttribute('role', 'option');\n      itemElement.setAttribute('aria-selected', 'false');\n      itemElement.setAttribute('aria-label', display(item));\n      if (templates?.suggestion) {\n        templatify(itemElement, templates.suggestion(item, resultSet));\n      } else {\n        itemElement.textContent = getNestedValue(item, keys[0]);\n      }\n      return itemElement;\n    };\n\n    // function to render typeahead groups\n    const renderGroup = (groupName: string): HTMLDivElement => {\n      const groupDiv = document.createElement('div');\n      groupDiv.classList.add(classNames.group);\n      groupDiv.setAttribute('role', 'group');\n      groupDiv.setAttribute('aria-label', groupName);\n      if (templates?.group) {\n        templatify(groupDiv, templates.group(groupName, resultSet));\n      } else {\n        groupDiv.textContent = groupName || '';\n      }\n      return groupDiv;\n    };\n\n    const fragment = document.createDocumentFragment();\n    const prevGroups: string[] = [];\n\n    // Add header template\n    if (templates?.header) {\n      const headerDiv = document.createElement('div');\n      headerDiv.classList.add(classNames.header);\n      headerDiv.setAttribute('role', 'presentation');\n      const templateHtml = templatify(headerDiv, templates.header(resultSet));\n      templateHtml && fragment.appendChild(headerDiv);\n    }\n\n    // loop over suggestions\n    for (const [index, item] of resultSet.hits.entries()) {\n      if (index === resultSet.limit) break;\n\n      // attach group if available\n      const groupVal = getNestedValue(item, groupKey);\n      if (groupVal && !prevGroups.includes(groupVal)) {\n        prevGroups.push(groupVal);\n        const groupDiv = renderGroup(groupVal);\n        fragment.appendChild(groupDiv);\n      }\n\n      // attach suggestion\n      const div = render(item);\n      div.addEventListener('click', (ev: MouseEvent): void => {\n        clear();\n        selected = item;\n        input.value = display(item, ev);\n        emitInputEvent();\n      });\n      if (item === selected) {\n        div.classList.add(classNames.selected);\n        div.setAttribute('aria-selected', 'true');\n      }\n      fragment.appendChild(div);\n\n      // highlight matched text\n      config.highlight !== false && highlight(div, resultSet.query);\n    }\n\n    // Add footer template\n    if (templates?.footer) {\n      const footerDiv = document.createElement('div');\n      footerDiv.classList.add(classNames.footer);\n      footerDiv.setAttribute('role', 'presentation');\n      const templateHtml = templatify(footerDiv, templates.footer(resultSet));\n      templateHtml && fragment.appendChild(footerDiv);\n    }\n\n    listContainer.appendChild(fragment);\n\n    // update hint if its enabled\n    hint && updateHint(selected || resultSet.hits[0]);\n\n    const scrollIntoViewIfNeeded = (element: HTMLDivElement) => {\n      if (element === null) return;\n      const rect = element.getBoundingClientRect();\n\n      const isAbove = rect.top < 0;\n      const isBelow = rect.bottom > (window.innerHeight || document.documentElement.clientHeight);\n      const isLeft = rect.left < 0;\n      const isRight = rect.right > (window.innerWidth || document.documentElement.clientWidth);\n\n      if (isAbove) {\n        window.scrollBy({ top: rect.top - 10, behavior: 'smooth' });\n      } else if (isBelow) {\n        window.scrollBy({\n          top: rect.bottom - (window.innerHeight || document.documentElement.clientHeight) + 10,\n          behavior: 'smooth',\n        });\n      }\n\n      if (isLeft) {\n        window.scrollBy({ left: rect.left - 10, behavior: 'smooth' });\n      } else if (isRight) {\n        window.scrollBy({\n          left: rect.right - (window.innerWidth || document.documentElement.clientWidth) + 10,\n          behavior: 'smooth',\n        });\n      }\n    };\n    // scroll when not in view\n    scrollIntoViewIfNeeded(listContainer.querySelector(`.${classNames.selected}`) as HTMLDivElement);\n\n    show();\n  };\n\n  const inputEventHandler = (ev: InputEvent): void => {\n    // Fix: Firefox Android uses insertCompositionText instead of insertText.\n    if (typeof ev.inputType === 'undefined' || (ev.inputType === 'insertCompositionText' && !ev.isComposing)) {\n      return;\n    }\n\n    storedInput = input.value;\n    startFetch();\n  };\n\n  /**\n   * Select the previous item in suggestions\n   */\n  const selectPrev = (ev: KeyboardEvent): void => {\n    const maxLength = resultSet.hits.length >= resultSet.limit ? resultSet.limit : resultSet.hits.length;\n    // if first item is selected and UP Key is pressed, focus input and restore original input\n    if (selected === resultSet.hits[0]) {\n      selected = undefined;\n      input.value = storedInput;\n      return;\n    }\n    // if focus is on input, and UP Key is pressed, select last item\n    if (!selected) {\n      selected = resultSet.hits[maxLength - 1];\n    } else {\n      for (let i = maxLength - 1; i > 0; i--) {\n        if (selected === resultSet.hits[i] || i === 1) {\n          selected = resultSet.hits[i - 1];\n          break;\n        }\n      }\n    }\n\n    input.value = display(selected, ev);\n  };\n\n  /**\n   * Select the next item in suggestions\n   */\n  const selectNext = (ev: KeyboardEvent): void => {\n    const maxLength = resultSet.hits.length >= resultSet.limit ? resultSet.limit : resultSet.hits.length;\n    // if nothing selected, select the first suggestion\n    if (!selected) {\n      selected = resultSet.hits[0];\n      input.value = display(selected, ev);\n      return;\n    }\n    // if we're at the end of the list, go to input box and restore original input\n    if (selected === resultSet.hits[maxLength - 1]) {\n      selected = undefined;\n      input.value = storedInput;\n      return;\n    }\n\n    for (let i = 0; i < maxLength - 1; i++) {\n      if (selected === resultSet.hits[i]) {\n        selected = resultSet.hits[i + 1];\n        break;\n      }\n    }\n\n    input.value = display(selected, ev);\n  };\n\n  const keydownEventHandler = (ev: KeyboardEvent): void => {\n    // if raw input is empty if Esc is hit, clear out everything\n    if (ev.key === 'Escape' || (!input.value.length && !resultSet.hits.length)) {\n      return clear();\n    }\n\n    if (resultSet.hits.length && (ev.key === 'ArrowUp' || ev.key === 'ArrowDown')) {\n      ev.key === 'ArrowDown' ? selectNext(ev) : selectPrev(ev);\n      update();\n\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      return;\n    }\n\n    const useSelectedValue = function (fallback = false) {\n      if (!selected && fallback && resultSet.hits.length) {\n        selected = resultSet.hits[0];\n      }\n      if (selected) {\n        clear();\n        input.value = display(selected, ev);\n        emitInputEvent();\n        return selected;\n      }\n    };\n\n    if (ev.key === 'Enter') {\n      preventSubmit && ev.preventDefault();\n      onSubmit(ev, useSelectedValue());\n\n      return;\n    }\n\n    if (ev.key === 'Tab' && isListOpen()) {\n      //ev.preventDefault();\n      useSelectedValue(true);\n    }\n  };\n\n  const focusEventHandler = (): void => {\n    if (prefetch?.when === 'onFocus') {\n      prefetchData();\n    }\n    startFetch();\n  };\n\n  const startFetch = (): void => {\n    clearRemoteDebounceTimer();\n    const val = input.value.replace(/\\s{2,}/g, ' ').trim();\n\n    // empty/default template\n    if (templates?.empty && !val.length) {\n      const emptyTemplateResp = templates.empty(resultSet);\n      resultSet.query = '';\n\n      // inject default suggestions if they were updated in the empty() template\n      if (Array.isArray(emptyTemplateResp) && emptyTemplateResp.length) {\n        resultSet.hits = normalizer(emptyTemplateResp, keys[0]) as T[];\n        return update();\n      }\n\n      // inject empty html template only if default suggestions aren't provided\n      clear();\n      clearListDOM();\n\n      if (emptyTemplateResp) {\n        const emptyEl = document.createElement('div');\n        emptyEl.classList.add(classNames.empty);\n        templatify(emptyEl, `${emptyTemplateResp}`);\n        listContainer.appendChild(emptyEl);\n      }\n\n      return show();\n    }\n\n    if (val.length >= minLen) {\n      resultSet.query = val;\n      calcSuggestions();\n\n      // if remote source exists, first check remote cache before making any query\n      const thumbprint = JSON.stringify(resultSet.query);\n      if (remote && resultSet.hits.length < resultSet.limit && (remoteResponseCache[thumbprint] as [])?.length) {\n        calcSuggestions(remoteResponseCache[thumbprint] as []);\n      }\n\n      update(); // update view\n\n      remoteDebounceTimer = setTimeout(() => {\n        if (resultSet.hits.length < resultSet.limit && !fetchInProgress) {\n          fetchDataFromRemote();\n        }\n      }, remote?.debounce || 200);\n    } else {\n      resultSet.query = '';\n      clear();\n    }\n  };\n\n  const formatQuery = (ip = '') => {\n    if (config.diacritics) {\n      ip = diacritics(ip);\n    }\n\n    return ip.toLowerCase();\n  };\n\n  const calcSuggestions = (newItems?: T[]): void => {\n    // get suggestions\n    let { suggestions, count }: { suggestions: T[]; count: number } = trie.search(resultSet.query, resultSet.limit);\n\n    if (newItems?.length) {\n      newItems.push(...suggestions); // merge suggestions\n\n      const uniqueItems = {} as Dictionary<T>;\n      for (const item of newItems) {\n        uniqueItems[identity(item)] = item;\n      }\n\n      suggestions = Object.values(uniqueItems);\n      count = suggestions.length;\n    }\n\n    // sort by starting letter of the query\n    sortByStartingLetter(suggestions);\n\n    // if suggestions need to be grouped, sort them by group\n    if (groupKey) {\n      sortByGroup(suggestions);\n    }\n\n    // update items with available suggestions\n    resultSet.hits = suggestions;\n    resultSet.count = count;\n\n    selected = undefined; // unselect previously calculated/cached suggestion\n    if (autoSelect && resultSet.hits.length) {\n      selected = resultSet.hits[0];\n    }\n  };\n\n  const fetchDataFromRemote = () => {\n    if (!remote) return;\n\n    fetchInProgress = true;\n    const frozenInput = resultSet.query;\n    const thumbprint = JSON.stringify(frozenInput);\n\n    // check cache, verify input length\n    if (remoteQueryCache[thumbprint] || !resultSet.query.length) {\n      fetchInProgress = false;\n      noSuggestionsHandler(true);\n      return;\n    }\n\n    loader();\n\n    let transformed: T[] = [];\n\n    fetchWrapper\n      .get(\n        typeof remote.url === 'function'\n          ? remote.url(frozenInput)\n          : remote.url.replace(remote.wildcard!, frozenInput),\n        remote.requestOptions\n      )\n      .then(\n        (data) => {\n          transformed = transform(data) as T[];\n          transformed = normalizer(transformed, keys[0]) as T[];\n          updateSearchIndex(transformed);\n        },\n        (reject) => {\n          console.error('e05', reject);\n        }\n      )\n      .finally(() => {\n        // cache XHR requests so that same calls aren't made multiple times\n        remoteQueryCache[thumbprint] = true;\n        remoteResponseCache[thumbprint] = transformed || [];\n        fetchInProgress = false;\n        loader();\n        if (transformed.length && resultSet.query.length) {\n          calcSuggestions(transformed);\n          update();\n        }\n\n        // make another request if inputVal exists but is different than the last remote request\n        if (resultSet.query.length && frozenInput !== resultSet.query) {\n          fetchDataFromRemote();\n        }\n        noSuggestionsHandler(true);\n      });\n  };\n\n  /**\n   * Update the search Index with the keys\n   */\n  function updateSearchIndex(iterable: T[]) {\n    if (!iterable.length) return;\n\n    // add new items to the search index\n    for (const token of keys) {\n      trie.add(iterable, token, identity);\n    }\n  }\n\n  /**\n   * Sorts array in place giving preference to the starting letter of the query\n   */\n  const sortByStartingLetter = (suggestions: T[]): void => {\n    const query = resultSet.query.toLowerCase();\n    suggestions.sort((one: Dictionary, two: Dictionary) => {\n      const a = getNestedValue(one, keys[0]).toLowerCase();\n      const b = getNestedValue(two, keys[0]).toLowerCase();\n\n      const startsWithA = a.startsWith(query);\n      const startsWithB = b.startsWith(query);\n\n      if (startsWithA && startsWithB) {\n        // If both start with the given string, sort by shortest length first\n        return a.length - b.length;\n      }\n      if (startsWithA) {\n        // If only A starts with the given string, it should come first\n        return -1;\n      }\n      if (startsWithB) {\n        // If only B starts with the given string, it should come first\n        return 1;\n      }\n\n      // If neither start with the given string, maintain original order\n      return 0;\n    });\n  };\n\n  /**\n   * Sorts(in-place) array by group\n   */\n  const sortByGroup = (suggestions: T[]) => {\n    suggestions.sort((a: Dictionary, b: Dictionary) => {\n      const aVal = getNestedValue(a, groupKey);\n      const bVal = getNestedValue(b, groupKey);\n\n      // if no groupKey was found, do not sort\n      if (!aVal && !bVal) return 0;\n      if (!aVal) {\n        return -1;\n      }\n      if (!bVal) {\n        return 1;\n      }\n      // sort in ascending order of group name\n      if (aVal < bVal) {\n        return -1;\n      }\n      if (aVal > bVal) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  /**\n   * Highlights a given text by its pattern\n   * @param Elm The listContainer element\n   * @param pattern the string to highlight\n   */\n  const highlight = (Elm: HTMLElement, pattern: string): void => {\n    if (!pattern) return;\n\n    const getRegex = (query: string) => {\n      const escapedQueries = tokenizer(query.trim())\n        .map((item) => escapeRegExp(item))\n        .sort((a, b) => b.length - a.length); // sort by string length to correctly highlight words\n      // @deprecated [selection by words]\n      // const regexStr = wordsOnly ? '\\\\b(' + escapedQueries.join('|') + ')\\\\b' : '(' + escapedQueries.join('|') + ')';\n      return new RegExp(`(${escapedQueries.join('|')})`, 'i');\n    };\n\n    const regex = getRegex(pattern);\n\n    const highlightTextNode = (textNode: Text) => {\n      let match = regex.exec(textNode.data);\n\n      // Check for diacritics if necessary\n      if (config.diacritics && !match) {\n        match = regex.exec(diacritics(textNode.data));\n      }\n\n      if (match) {\n        const wrapperNode = document.createElement('span');\n        wrapperNode.className = classNames.highlight;\n\n        const patternNode = textNode.splitText(match.index);\n        patternNode.splitText(match[0].length);\n        wrapperNode.appendChild(patternNode.cloneNode(true));\n\n        textNode.parentNode?.replaceChild(wrapperNode, patternNode);\n        return true;\n      }\n      return false;\n    };\n\n    const traverse = (el: HTMLElement | ChildNode, highlightTextNode: (textNode: Text) => boolean) => {\n      const TEXT_NODE_TYPE = 3;\n      let childNode;\n\n      for (let i = 0; i < el.childNodes.length; i++) {\n        childNode = el.childNodes[i];\n\n        if (childNode.nodeType === TEXT_NODE_TYPE) {\n          i += highlightTextNode(childNode as Text) ? 1 : 0;\n        } else {\n          traverse(childNode, highlightTextNode);\n        }\n      }\n    };\n\n    traverse(Elm, highlightTextNode);\n  };\n\n  /**\n   * injects Hint input element into the DOM\n   * @param inputHint the input hint element\n   */\n  function injectHintEl(inputHint: HTMLInputElement) {\n    ['id', 'name', 'placeholder', 'required', 'aria-label'].forEach((attr) => inputHint.removeAttribute(attr));\n    inputHint.setAttribute('readonly', 'true');\n    inputHint.setAttribute('aria-hidden', 'true');\n    inputHint.style.marginTop = `-${input.offsetHeight + parseInt(computedInputStyle.marginBottom)}px`; // super-impose hint on input\n    inputHint.tabIndex = -1;\n    inputHint.className = classNames.hint;\n\n    input.after(inputHint);\n  }\n\n  /**\n   * Updates the value of hint\n   * @param selectedItem The selected item\n   */\n  const updateHint = (selectedItem: T) => {\n    const rawInput = input.value;\n\n    // if raw string is not part of suggestion, hide the hint\n    if (\n      !rawInput ||\n      display(selectedItem) === rawInput || // if input string is exactly the same as selectedItem\n      formatQuery(display(selectedItem)).indexOf(\n        formatQuery(rawInput)\n          .replace(/\\s{2,}/g, ' ')\n          .trimStart()\n      ) !== 0\n    ) {\n      inputHint.value = '';\n    } else {\n      const item = display(selectedItem);\n      const regex = new RegExp(escapeRegExp(resultSet.query), 'i');\n      let match = regex.exec(item);\n\n      // check for diacritics if necessary\n      if (config.diacritics && !match) {\n        match = regex.exec(diacritics(item));\n      }\n\n      if (match) {\n        inputHint.value = (rawInput.replace(/\\s?$/, '') + item.substring(match[0].length)) as string;\n      }\n    }\n  };\n\n  /**\n   * Creates and appends a template to an HTMLElement\n   * @param El The html element that the template should attach to\n   * @param templateHtml The raw string representation of the html template\n   */\n  const templatify = (El: HTMLElement | DocumentFragment, templateHtml: string) => {\n    const template = document.createElement('template');\n    template.innerHTML = templateHtml;\n    El.appendChild(template.content);\n    return templateHtml;\n  };\n\n  const blurEventHandler = (): void => {\n    // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n    setTimeout(() => {\n      if (document.activeElement !== input) {\n        clear();\n      }\n    }, 50);\n  };\n\n  /**\n   * Handle Long clicks\n   */\n  listContainer.addEventListener('mousedown', function (e: Event) {\n    e.stopPropagation();\n    e.preventDefault();\n  });\n\n  /**\n   * Resets the typeahead instance and clears everything\n   * Clears the search index as well as the entire cache\n   * clearLocalSrc?: boolean, if true, clears even the suggestions added via the Local Source\n   * */\n  const reset = (clearLocalSrc?: boolean) => {\n    clear();\n    trie.clear();\n    local && !clearLocalSrc && addToIndex(local);\n    remoteQueryCache = {};\n    remoteResponseCache = {};\n    if (prefetch) {\n      prefetch.done = false;\n    }\n  };\n\n  /**\n   * This function will remove DOM elements, clears cache and removes all event handlers\n   */\n  const destroy = (): void => {\n    clearRemoteDebounceTimer();\n    reset();\n    wrapper.replaceWith(input.cloneNode());\n  };\n\n  // setup event handlers\n  input.addEventListener('keydown', keydownEventHandler);\n  input.addEventListener('input', inputEventHandler as EventListenerOrEventListenerObject);\n  input.addEventListener('blur', blurEventHandler);\n  input.addEventListener('focus', focusEventHandler);\n\n  return {\n    addToIndex,\n    reset,\n    destroy,\n    // trie, // trie exposed only for local tests\n  };\n};\n\nexport default typeahead;"],"names":["NOOP","args","escapeRegExp","text","isObject","item","isString","getNestedValue","obj","selector","ref","keys","key","diacritics","txt","normalizer","listItems","spaceTokenizer","tokenString","get","url","requestOptions","response","handleResponse","data","fetchWrapper","Trie","config","hasDiacritics","tokenizer","root","SENTINEL","tokenize","value","add","identity","node","isStringArr","dataTokens","prefix","char","uniqueId","sentinelNode","find","matches","stack","k","results","resultKey","intersectDictionaries","dict1","dict2","result","search","query","limit","queryTokens","queryTokenLimit","suggestions","i","count","clear","typeahead","listContainer","preventSubmit","minLen","hint","autoSelect","templates","groupKey","displayCb","display","onSubmit","transform","local","remoteUrlType","remote","prefetch","classNames","trie","wrapper","resultSet","remoteQueryCache","remoteResponseCache","selected","remoteDebounceTimer","fetchInProgress","storedInput","addToIndex","updateSearchIndex","input","computedInputStyle","parentEl","inputIndex","inputHint","injectHintEl","prefetchData","transformed","reject","show","hide","isListOpen","clearRemoteDebounceTimer","emitInputEvent","noSuggestionsHandler","asyncRender","clearListDOM","notFoundTemplateHtml","renderNotFoundTemplate","html","notFoundEl","templatify","loader","loaderEl","loaderDiv","update","render","itemElement","renderGroup","groupName","groupDiv","fragment","prevGroups","headerDiv","index","groupVal","div","ev","highlight","footerDiv","updateHint","element","rect","isAbove","isBelow","isLeft","isRight","inputEventHandler","startFetch","selectPrev","maxLength","selectNext","keydownEventHandler","useSelectedValue","fallback","focusEventHandler","val","emptyTemplateResp","emptyEl","calcSuggestions","thumbprint","fetchDataFromRemote","formatQuery","ip","newItems","uniqueItems","sortByStartingLetter","sortByGroup","frozenInput","iterable","token","one","two","a","b","startsWithA","startsWithB","aVal","bVal","Elm","pattern","regex","escapedQueries","highlightTextNode","textNode","match","wrapperNode","patternNode","traverse","el","childNode","attr","selectedItem","rawInput","El","templateHtml","template","blurEventHandler","reset","clearLocalSrc","destroy"],"mappings":"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"}