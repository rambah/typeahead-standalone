{"version":3,"file":"typeahead-standalone.umd.js","sources":["../src/helpers.ts","../src/fetchWrapper/fetchWrapper.ts","../src/trie/trie.ts","../src/typeahead-standalone.ts"],"sourcesContent":["import type { Dictionary } from './common.d.ts';\n\nexport const NOOP = (...args: unknown[]): void => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: unknown): item is Dictionary => {\n  return item !== null && (item as Dictionary)?.constructor.name === 'Object';\n};\n\nexport const isString = (item: unknown): item is string => typeof item === 'string';\n\nexport const getNestedValue = (obj: unknown, selector: string): string => {\n  let ref: any = obj;\n  const keys = selector.split('.');\n\n  for (const key of keys) {\n    if (!isObject(ref) || !(key in ref)) {\n      return '';\n    }\n    ref = ref[key];\n  }\n\n  return `${ref}`;\n};\n\n/** @deprecated */\nexport const deduplicateArr = (iterable: Dictionary[], prop: string): Dictionary[] => [\n  ...new Map(iterable.map((item) => [item[prop], item])).values(),\n];\n\nexport const diacritics = (txt = '') => txt.normalize('NFD').replace(/\\p{Diacritic}/gu, '');\n\n/****** helpers specific to typeahead  *****/\n\nexport const normalizer = <T extends Dictionary>(listItems: string[] | Dictionary[] | T[], key: string): T[] => {\n  if (!listItems.length) return [];\n\n  // validate array of objects\n  if (isObject(listItems[0])) {\n    // verify if key exists (i.e. normalized already)\n    for (const item of listItems) {\n      if (!getNestedValue(item, key)) {\n        throw new Error('e03');\n      }\n    }\n\n    return listItems as T[];\n  }\n\n  // normalize array of strings\n  return (listItems as string[]).map((item) => ({\n    [key]: isString(item) ? item : JSON.stringify(item),\n  })) as T[];\n};\n\n/****** helpers specific to Trie  *****/\n\nexport const spaceTokenizer = (tokenString: string): string[] => tokenString.split(/\\s+/);\n","// A custom FETCH API wrapper\n// inspired by https://jasonwatmore.com/post/2020/04/18/fetch-a-lightweight-fetch-wrapper-to-simplify-http-requests\n\nconst get = async function (url: RequestInfo | URL, requestOptions?: RequestInit): Promise<any> {\n  const response = await fetch(\n    url,\n    requestOptions || {\n      method: 'GET',\n    }\n  );\n  return handleResponse(response);\n};\n\n// helper function\nconst handleResponse = async function (response: Response) {\n  const text = await response.text();\n  const data = text && JSON.parse(text);\n  if (!response.ok) {\n    return Promise.reject((data && data.message) || response.statusText);\n  }\n  return data;\n};\n\nexport const fetchWrapper = {\n  get,\n};\n\n/*\n * @deprecated: Post method not required at the moment\n */\n// const post = async function (url: string, body: unknown): Promise<any> {\n//   const requestOptions = {\n//     method: 'POST',\n//     headers: { 'Content-Type': 'application/json' },\n//     body: JSON.stringify(body),\n//   };\n//   const response = await fetch(url, requestOptions);\n//   return handleResponse(response);\n// };\n","import type { Dictionary } from '../common.d.ts';\nimport type { SearchResults, TrieType } from './types.d.ts';\nimport { spaceTokenizer, diacritics, getNestedValue, isString } from '../helpers.js';\n\n// Trie algorithm (inspired by data structures @https://github.com/Yomguithereal/mnemonist)\nexport const Trie: TrieType<any> = (config = {}) => {\n  const { hasDiacritics, tokenizer } = config;\n  let root: Record<string, unknown> = {};\n\n  // marks the end of a string\n  const SENTINEL = String.fromCharCode(0);\n\n  /**\n   * Returns data/query tokens\n   */\n  function tokenize(value = '') {\n    value = `${value}`.trim(); // coerce to string and trim\n\n    if (hasDiacritics) {\n      value = diacritics(value);\n    }\n    // make search case insensitive\n    return (tokenizer || spaceTokenizer)(value.toLowerCase());\n  }\n\n  /**\n   * Method used to add the given data to the trie.\n   * key is optional when data is a string|string[], but mandatory for Dictionary[]\n   */\n  function add(data: string | string[] | Dictionary[], key = '', identity?: (item?: unknown) => string): void {\n    if (!data) return;\n\n    let node: Record<string, unknown>;\n    data = Array.isArray(data) ? data : [data];\n    const isStringArr = isString(data[0]);\n\n    for (const value of data) {\n      // we tokenize the incoming data to make search possible by fragments\n      const dataTokens = tokenize(isStringArr ? (value as string) : getNestedValue(value, key));\n      for (const prefix of dataTokens) {\n        if (!prefix) continue; // filter out falsy values\n\n        node = root;\n\n        for (const char of prefix) {\n          node = (node[char] ||= {}) as Record<string, unknown>;\n        }\n\n        const uniqueId = isStringArr ? value : (identity && identity(value)) || JSON.stringify(value);\n        const sentinelNode = (node[SENTINEL] ??= {});\n        (sentinelNode as Dictionary)[uniqueId as string] = value;\n      }\n    }\n  }\n\n  /**\n   * Internal Method used to retrieve items in the trie beginning with the given prefix.\n   */\n  function find(prefix: string): Dictionary {\n    let node = root;\n    let matches: Dictionary = {};\n\n    // traverse the root until you reach the end of prefix\n    for (const char of prefix) {\n      node = node?.[char] as Record<string, unknown>;\n      if (typeof node === 'undefined') return {};\n    }\n\n    // Performing DFS (Depth-First Search) from prefix to traverse the tree\n    const stack = [{ node, prefix }];\n\n    while (stack.length) {\n      const { node, prefix } = stack.pop() as { node: Record<string, unknown>; prefix: string };\n\n      for (const k in node) {\n        if (k === SENTINEL) {\n          // Object.assign(matches, node[SENTINEL]);\n          const results = node[SENTINEL] as Dictionary;\n          for (const resultKey in results) {\n            matches[resultKey] = results[resultKey];\n          }\n        } else {\n          stack.push({ node: node[k] as Record<string, unknown>, prefix: prefix + k });\n        }\n      }\n    }\n\n    return matches as Dictionary;\n  }\n\n  // Returns the intersection of two dictionaries\n  const intersectDictionaries = (dict1: Dictionary, dict2: Dictionary): Dictionary => {\n    const result: Dictionary = {};\n    for (const key in dict1) {\n      if (key in dict2) {\n        result[key] = dict1[key];\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Search for query strings within the trie\n   */\n  function search(query: string, limit?: number): SearchResults<Dictionary | string> {\n    const queryTokens = tokenize(query);\n\n    // limit input queries to 20 tokens/words for improved performance\n    const queryTokenLimit = queryTokens.length <= 20 ? queryTokens.length : 20;\n\n    // Search for multiple tokens/queries and get initial matches\n    let suggestions: Dictionary | Dictionary[] = find(queryTokens[0]);\n\n    for (let i = 1; i < queryTokenLimit; i++) {\n      suggestions = intersectDictionaries(suggestions, find(queryTokens[i])); // get intersection of found suggestions\n      if (!Object.keys(suggestions).length) break; // exit if no matches are found\n    }\n\n    suggestions = Object.values(suggestions) as Dictionary[];\n\n    const count = suggestions.length;\n\n    // truncate suggestions to limit\n    if (limit && count > limit) {\n      suggestions.length = limit;\n    }\n\n    return {\n      suggestions,\n      count,\n    };\n  }\n\n  function clear() {\n    root = {};\n  }\n\n  return {\n    add,\n    clear,\n    search,\n  };\n};\n","/*\n * https://github.com/digitalfortress-tech/typeahead-standalone\n * Copyright (c) 2020 Niket Pathak\n * MIT License\n */\n\nimport type {\n  typeaheadResult,\n  typeaheadConfig,\n  typeaheadHtmlTemplates,\n  Dictionary,\n  LocalDataSource,\n  RemoteDataSource,\n  PrefetchDataSource,\n  ResultSet,\n  typeaheadStyleClasses,\n} from './common.d.ts';\nimport { diacritics, escapeRegExp, getNestedValue, isObject, NOOP, normalizer, spaceTokenizer } from './helpers.js';\nimport { fetchWrapper } from './fetchWrapper/fetchWrapper.js';\nimport { Trie } from './trie/trie.js';\nimport './style.less';\n\nconst typeahead = <T extends Dictionary>(config: typeaheadConfig<T>): typeaheadResult<T> => {\n  // check required params\n  if (!config.input) throw new Error('e01');\n  if (!isObject(config.source)) throw new Error('e02');\n\n  const listContainer: HTMLDivElement = document.createElement('div');\n  const preventSubmit = config.preventSubmit || false;\n  const minLen = config.minLength || 1;\n  const hint = config.hint === false ? false : true;\n  const autoSelect = config.autoSelect || false;\n  const tokenizer = config.tokenizer || spaceTokenizer;\n  const templates: typeaheadHtmlTemplates<T> | undefined = config.templates;\n  const keys = Array.isArray(config.source.keys) ? config.source.keys : ['label']; // \"label\" is the default key\n  const groupKey = config.source.groupKey || '';\n  const displayCb = <T extends Dictionary>(item: T): string => getNestedValue(item, keys[0]);\n  const display: (item: T, e?: MouseEvent | KeyboardEvent | null) => string = config.display || displayCb;\n  const identity = config.source.identity || displayCb;\n  const onSubmit: (e: Event, item?: T) => void = config.onSubmit || NOOP;\n  const transform = config.source.transform || ((data) => data);\n  const local = (config.source as LocalDataSource<T>).local || null;\n  const remoteUrlType = typeof (config.source as RemoteDataSource<T>).remote?.url;\n  const remote =\n    remoteUrlType === 'function' ||\n    (remoteUrlType === 'string' && (config.source as RemoteDataSource<T>).remote.wildcard)\n      ? (config.source as RemoteDataSource<T>).remote\n      : null;\n  const prefetch = (config.source as PrefetchDataSource<T>).prefetch?.url\n    ? { ...{ when: 'onInit', done: false }, ...(config.source as PrefetchDataSource<T>).prefetch }\n    : null;\n  const classNames: typeaheadStyleClasses = {\n    wrapper: 'typeahead-standalone',\n    input: 'tt-input',\n    hint: 'tt-hint',\n    highlight: 'tt-highlight',\n    hide: 'tt-hide',\n    show: 'tt-show',\n    list: 'tt-list',\n    selected: 'tt-selected',\n    header: 'tt-header',\n    footer: 'tt-footer',\n    loader: 'tt-loader',\n    suggestion: 'tt-suggestion',\n    group: 'tt-group',\n    empty: 'tt-empty',\n    notFound: 'tt-notFound',\n    ...(config.classNames || {}),\n  };\n\n  // validate presence of atleast one data-source\n  if (!local && !prefetch && !remote) throw new Error('e02');\n\n  // initialise trie if atleast 1 source exists\n  const trie = Trie({ hasDiacritics: config.diacritics, tokenizer });\n\n  // Main Wrapper/container element\n  const wrapper: HTMLDivElement = document.createElement('div');\n  wrapper.className = classNames.wrapper;\n\n  const resultSet: ResultSet<T> = {\n    query: '',\n    hits: [], // suggestions\n    count: 0,\n    limit: config.limit || 5,\n    wrapper,\n  };\n\n  let remoteQueryCache: Dictionary = {};\n  let remoteResponseCache: Dictionary = {};\n\n  let selected: T | undefined;\n  let remoteDebounceTimer: NodeJS.Timeout;\n  let fetchInProgress = false;\n  let storedInput = ''; // used only for keyboard navigation\n\n  // init templates if they exist\n  if (templates) {\n    templates.header = typeof templates.header === 'function' ? templates.header : undefined;\n    templates.footer = typeof templates.footer === 'function' ? templates.footer : undefined;\n    templates.notFound = typeof templates.notFound === 'function' ? templates.notFound : undefined;\n    templates.group = typeof templates.group === 'function' ? templates.group : undefined;\n    templates.suggestion = typeof templates.suggestion === 'function' ? templates.suggestion : undefined;\n    templates.loader = typeof templates.loader === 'function' ? templates.loader : undefined;\n    templates.empty = typeof templates.empty === 'function' ? templates.empty : undefined;\n  }\n\n  const addToIndex = (suggestions: string[] | Dictionary[] | T[] = []) => {\n    updateSearchIndex(normalizer(suggestions, keys[0]) as T[]);\n  };\n\n  // if local source exists, add the suggestions to the index\n  local && addToIndex(local);\n\n  const input: HTMLInputElement = config.input;\n  input.classList.add(classNames.input);\n  const computedInputStyle = window.getComputedStyle(input);\n\n  // move input element into the wrapper element\n  const parentEl = input.parentNode as HTMLElement;\n  const inputIndex = [...parentEl.children].indexOf(input);\n  parentEl.removeChild(input);\n  wrapper.appendChild(input);\n\n  // append Wrapper element to the original parent\n  parentEl.insertBefore(wrapper, parentEl.children[inputIndex]);\n\n  // generate markup for hints\n  const inputHint: HTMLInputElement = input.cloneNode() as HTMLInputElement;\n  hint && injectHintEl(inputHint);\n\n  listContainer.classList.add(classNames.list, classNames.hide);\n  listContainer.setAttribute('aria-label', 'menu-options');\n  listContainer.setAttribute('role', 'listbox');\n\n  // set listContainer positioning\n  listContainer.style.position = 'absolute'; // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n  listContainer.style.width = `${input.offsetWidth}px`;\n  listContainer.style.marginTop = `${input.offsetHeight + parseInt(computedInputStyle.marginTop)}px`;\n\n  // Attach list container\n  wrapper.appendChild(listContainer);\n\n  if (prefetch && prefetch.when === 'onInit') {\n    prefetchData();\n  }\n\n  function prefetchData() {\n    // check if data was already prefetched for current session\n    if (!prefetch || prefetch.done) return;\n\n    let transformed: T[] = [];\n\n    fetchWrapper\n      .get(typeof prefetch.url === 'function' ? prefetch.url() : prefetch.url, prefetch?.requestOptions)\n      .then(\n        (data) => {\n          transformed = transform(data) as T[];\n          transformed = normalizer(transformed, keys[0]) as T[];\n          updateSearchIndex(transformed);\n        },\n        (reject) => {\n          console.error('e04', reject);\n        }\n      )\n      .finally(() => {\n        typeof prefetch.process === 'function' && prefetch.process(transformed);\n      });\n\n    prefetch.done = true;\n  }\n\n  /**\n   * Display/show the listContainer\n   */\n  const show = (): void => {\n    listContainer.classList.remove(classNames.hide);\n  };\n\n  /**\n   * Hides the listContainer from DOM\n   */\n  const hide = (): void => {\n    listContainer.classList.add(classNames.hide);\n  };\n\n  /**\n   * Flag to indicate if the list of suggestions is open or not\n   * @returns Boolean\n   */\n  const isListOpen = (): boolean => !listContainer.classList.contains(classNames.hide);\n\n  /**\n   * Clear remote debounce timer if assigned\n   */\n  const clearRemoteDebounceTimer = (): void => remoteDebounceTimer && clearTimeout(remoteDebounceTimer);\n\n  /**\n   * Clear typeahead state and hide listContainer\n   */\n  const clear = (): void => {\n    resultSet.hits = [];\n    inputHint.value = '';\n    storedInput = '';\n    hide();\n  };\n\n  /*\n   * Triggers a user input event\n   */\n  const emitInputEvent = (): void => {\n    input.dispatchEvent(\n      new InputEvent('input', {\n        bubbles: true,\n        inputType: 'insertCompositionText',\n        data: input.value,\n      })\n    );\n  };\n\n  /**\n   * Displays the NotFound template if it exists, otherwise, does nothing (i.e. returns true)\n   * @param asyncRender set to true for asyncRenders\n   * @returns true if no suggestions are found, else returns undefined\n   */\n  const noSuggestionsHandler = (asyncRender = false) => {\n    if (!resultSet.hits.length && resultSet.query) {\n      // clear the list and the DOM\n      clear();\n      clearListDOM();\n\n      const notFoundTemplateHtml = templates?.notFound?.(resultSet);\n      if (!notFoundTemplateHtml) return true;\n\n      const renderNotFoundTemplate = (html: string) => {\n        const notFoundEl = document.createElement('div');\n        notFoundEl.classList.add(classNames.notFound);\n        templatify(notFoundEl, html);\n        listContainer.appendChild(notFoundEl);\n      };\n\n      if (!remote) {\n        renderNotFoundTemplate(notFoundTemplateHtml);\n      } else if (remoteQueryCache[JSON.stringify(resultSet.query)] || (asyncRender && !fetchInProgress)) {\n        // wait for remote results before rendering notFoundTemplate / render immediately if request was cached\n        renderNotFoundTemplate(notFoundTemplateHtml);\n      }\n\n      show();\n      return true;\n    }\n  };\n\n  /**\n   * Delete all children from typeahead DOM listContainer\n   */\n  const clearListDOM = () => {\n    while (listContainer.firstChild) {\n      listContainer.firstChild.remove();\n    }\n  };\n\n  const loader = () => {\n    if (!templates?.loader) {\n      return;\n    }\n\n    if (!fetchInProgress) {\n      const loaderEl = listContainer.querySelector(`.${classNames.loader}`);\n      loaderEl && listContainer.removeChild(loaderEl);\n      return;\n    }\n\n    // display spinner/loader\n    const loaderDiv = document.createElement('div');\n    loaderDiv.classList.add(classNames.loader);\n    templatify(loaderDiv, templates.loader());\n    if (templates?.footer) {\n      listContainer.insertBefore(loaderDiv, listContainer.querySelector(`.${classNames.footer}`));\n    } else {\n      listContainer.appendChild(loaderDiv);\n    }\n  };\n\n  /**\n   * Responsible for drawing/updating the view\n   */\n  const update = (): void => {\n    // No Matches\n    if (noSuggestionsHandler()) return;\n\n    clearListDOM();\n\n    // function for rendering typeahead suggestions\n    const render = (item: T): HTMLDivElement => {\n      const itemElement = document.createElement('div');\n      itemElement.classList.add(classNames.suggestion);\n      itemElement.setAttribute('role', 'option');\n      itemElement.setAttribute('aria-selected', 'false');\n      itemElement.setAttribute('aria-label', display(item));\n      if (templates?.suggestion) {\n        templatify(itemElement, templates.suggestion(item, resultSet));\n      } else {\n        itemElement.textContent = getNestedValue(item, keys[0]);\n      }\n      return itemElement;\n    };\n\n    // function to render typeahead groups\n    const renderGroup = (groupName: string): HTMLDivElement => {\n      const groupDiv = document.createElement('div');\n      groupDiv.classList.add(classNames.group);\n      groupDiv.setAttribute('role', 'group');\n      groupDiv.setAttribute('aria-label', groupName);\n      if (templates?.group) {\n        templatify(groupDiv, templates.group(groupName, resultSet));\n      } else {\n        groupDiv.textContent = groupName || '';\n      }\n      return groupDiv;\n    };\n\n    const fragment = document.createDocumentFragment();\n    const prevGroups: string[] = [];\n\n    // Add header template\n    if (templates?.header) {\n      const headerDiv = document.createElement('div');\n      headerDiv.classList.add(classNames.header);\n      headerDiv.setAttribute('role', 'presentation');\n      const templateHtml = templatify(headerDiv, templates.header(resultSet));\n      templateHtml && fragment.appendChild(headerDiv);\n    }\n\n    // loop over suggestions\n    for (const [index, item] of resultSet.hits.entries()) {\n      if (index === resultSet.limit) break;\n\n      // attach group if available\n      const groupVal = getNestedValue(item, groupKey);\n      if (groupVal && !prevGroups.includes(groupVal)) {\n        prevGroups.push(groupVal);\n        const groupDiv = renderGroup(groupVal);\n        fragment.appendChild(groupDiv);\n      }\n\n      // attach suggestion\n      const div = render(item);\n      div.addEventListener('click', (ev: MouseEvent): void => {\n        clear();\n        selected = item;\n        input.value = display(item, ev);\n        emitInputEvent();\n      });\n      if (item === selected) {\n        div.classList.add(classNames.selected);\n        div.setAttribute('aria-selected', 'true');\n      }\n      fragment.appendChild(div);\n\n      // highlight matched text\n      config.highlight !== false && highlight(div, resultSet.query);\n    }\n\n    // Add footer template\n    if (templates?.footer) {\n      const footerDiv = document.createElement('div');\n      footerDiv.classList.add(classNames.footer);\n      footerDiv.setAttribute('role', 'presentation');\n      const templateHtml = templatify(footerDiv, templates.footer(resultSet));\n      templateHtml && fragment.appendChild(footerDiv);\n    }\n\n    listContainer.appendChild(fragment);\n\n    // update hint if its enabled\n    hint && updateHint(selected || resultSet.hits[0]);\n\n    const scrollIntoViewIfNeeded = (element: HTMLDivElement) => {\n      if (element === null) return;\n      const rect = element.getBoundingClientRect();\n\n      const isAbove = rect.top < 0;\n      const isBelow = rect.bottom > (window.innerHeight || document.documentElement.clientHeight);\n      const isLeft = rect.left < 0;\n      const isRight = rect.right > (window.innerWidth || document.documentElement.clientWidth);\n\n      if (isAbove) {\n        window.scrollBy({ top: rect.top - 10, behavior: 'smooth' });\n      } else if (isBelow) {\n        window.scrollBy({\n          top: rect.bottom - (window.innerHeight || document.documentElement.clientHeight) + 10,\n          behavior: 'smooth',\n        });\n      }\n\n      if (isLeft) {\n        window.scrollBy({ left: rect.left - 10, behavior: 'smooth' });\n      } else if (isRight) {\n        window.scrollBy({\n          left: rect.right - (window.innerWidth || document.documentElement.clientWidth) + 10,\n          behavior: 'smooth',\n        });\n      }\n    };\n    // scroll when not in view\n    scrollIntoViewIfNeeded(listContainer.querySelector(`.${classNames.selected}`) as HTMLDivElement);\n\n    show();\n  };\n\n  const inputEventHandler = (ev: InputEvent): void => {\n    // Fix: Firefox Android uses insertCompositionText instead of insertText.\n    if (typeof ev.inputType === 'undefined' || (ev.inputType === 'insertCompositionText' && !ev.isComposing)) {\n      return;\n    }\n\n    storedInput = input.value;\n    startFetch();\n  };\n\n  /**\n   * Select the previous item in suggestions\n   */\n  const selectPrev = (ev: KeyboardEvent): void => {\n    const maxLength = resultSet.hits.length >= resultSet.limit ? resultSet.limit : resultSet.hits.length;\n    // if first item is selected and UP Key is pressed, focus input and restore original input\n    if (selected === resultSet.hits[0]) {\n      selected = undefined;\n      input.value = storedInput;\n      return;\n    }\n    // if focus is on input, and UP Key is pressed, select last item\n    if (!selected) {\n      selected = resultSet.hits[maxLength - 1];\n    } else {\n      for (let i = maxLength - 1; i > 0; i--) {\n        if (selected === resultSet.hits[i] || i === 1) {\n          selected = resultSet.hits[i - 1];\n          break;\n        }\n      }\n    }\n\n    input.value = display(selected, ev);\n  };\n\n  /**\n   * Select the next item in suggestions\n   */\n  const selectNext = (ev: KeyboardEvent): void => {\n    const maxLength = resultSet.hits.length >= resultSet.limit ? resultSet.limit : resultSet.hits.length;\n    // if nothing selected, select the first suggestion\n    if (!selected) {\n      selected = resultSet.hits[0];\n      input.value = display(selected, ev);\n      return;\n    }\n    // if we're at the end of the list, go to input box and restore original input\n    if (selected === resultSet.hits[maxLength - 1]) {\n      selected = undefined;\n      input.value = storedInput;\n      return;\n    }\n\n    for (let i = 0; i < maxLength - 1; i++) {\n      if (selected === resultSet.hits[i]) {\n        selected = resultSet.hits[i + 1];\n        break;\n      }\n    }\n\n    input.value = display(selected, ev);\n  };\n\n  const keydownEventHandler = (ev: KeyboardEvent): void => {\n    // if raw input is empty if Esc is hit, clear out everything\n    if (ev.key === 'Escape' || (!input.value.length && !resultSet.hits.length)) {\n      return clear();\n    }\n\n    if (resultSet.hits.length && (ev.key === 'ArrowUp' || ev.key === 'ArrowDown')) {\n      ev.key === 'ArrowDown' ? selectNext(ev) : selectPrev(ev);\n      update();\n\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      return;\n    }\n\n    const useSelectedValue = function (fallback = false) {\n      if (!selected && fallback && resultSet.hits.length) {\n        selected = resultSet.hits[0];\n      }\n      if (selected) {\n        clear();\n        input.value = display(selected, ev);\n        emitInputEvent();\n        return selected;\n      }\n    };\n\n    if (ev.key === 'Enter') {\n      preventSubmit && ev.preventDefault();\n      onSubmit(ev, useSelectedValue());\n\n      return;\n    }\n\n    if (ev.key === 'Tab' && isListOpen()) {\n      ev.preventDefault();\n      useSelectedValue(true);\n    }\n  };\n\n  const focusEventHandler = (): void => {\n    if (prefetch?.when === 'onFocus') {\n      prefetchData();\n    }\n    startFetch();\n  };\n\n  const startFetch = (): void => {\n    clearRemoteDebounceTimer();\n    const val = input.value.replace(/\\s{2,}/g, ' ').trim();\n\n    // empty/default template\n    if (templates?.empty && !val.length) {\n      const emptyTemplateResp = templates.empty(resultSet);\n      resultSet.query = '';\n\n      // inject default suggestions if they were updated in the empty() template\n      if (Array.isArray(emptyTemplateResp) && emptyTemplateResp.length) {\n        resultSet.hits = normalizer(emptyTemplateResp, keys[0]) as T[];\n        return update();\n      }\n\n      // inject empty html template only if default suggestions aren't provided\n      clear();\n      clearListDOM();\n\n      if (emptyTemplateResp) {\n        const emptyEl = document.createElement('div');\n        emptyEl.classList.add(classNames.empty);\n        templatify(emptyEl, `${emptyTemplateResp}`);\n        listContainer.appendChild(emptyEl);\n      }\n\n      return show();\n    }\n\n    if (val.length >= minLen) {\n      resultSet.query = val;\n      calcSuggestions();\n\n      // if remote source exists, first check remote cache before making any query\n      const thumbprint = JSON.stringify(resultSet.query);\n      if (remote && resultSet.hits.length < resultSet.limit && (remoteResponseCache[thumbprint] as [])?.length) {\n        calcSuggestions(remoteResponseCache[thumbprint] as []);\n      }\n\n      update(); // update view\n\n      remoteDebounceTimer = setTimeout(() => {\n        if (resultSet.hits.length < resultSet.limit && !fetchInProgress) {\n          fetchDataFromRemote();\n        }\n      }, remote?.debounce || 200);\n    } else {\n      resultSet.query = '';\n      clear();\n    }\n  };\n\n  const formatQuery = (ip = '') => {\n    if (config.diacritics) {\n      ip = diacritics(ip);\n    }\n\n    return ip.toLowerCase();\n  };\n\n  const calcSuggestions = (newItems?: T[]): void => {\n    // get suggestions\n    let { suggestions, count }: { suggestions: T[]; count: number } = trie.search(resultSet.query, resultSet.limit);\n\n    if (newItems?.length) {\n      newItems.push(...suggestions); // merge suggestions\n\n      const uniqueItems = {} as Dictionary<T>;\n      for (const item of newItems) {\n        uniqueItems[identity(item)] = item;\n      }\n\n      suggestions = Object.values(uniqueItems);\n      count = suggestions.length;\n    }\n\n    // sort by starting letter of the query\n    sortByStartingLetter(suggestions);\n\n    // if suggestions need to be grouped, sort them by group\n    if (groupKey) {\n      sortByGroup(suggestions);\n    }\n\n    // update items with available suggestions\n    resultSet.hits = suggestions;\n    resultSet.count = count;\n\n    selected = undefined; // unselect previously calculated/cached suggestion\n    if (autoSelect && resultSet.hits.length) {\n      selected = resultSet.hits[0];\n    }\n  };\n\n  const fetchDataFromRemote = () => {\n    if (!remote) return;\n\n    fetchInProgress = true;\n    const frozenInput = resultSet.query;\n    const thumbprint = JSON.stringify(frozenInput);\n\n    // check cache, verify input length\n    if (remoteQueryCache[thumbprint] || !resultSet.query.length) {\n      fetchInProgress = false;\n      noSuggestionsHandler(true);\n      return;\n    }\n\n    loader();\n\n    let transformed: T[] = [];\n\n    fetchWrapper\n      .get(\n        typeof remote.url === 'function'\n          ? remote.url(frozenInput)\n          : remote.url.replace(remote.wildcard!, frozenInput),\n        remote.requestOptions\n      )\n      .then(\n        (data) => {\n          transformed = transform(data) as T[];\n          transformed = normalizer(transformed, keys[0]) as T[];\n          updateSearchIndex(transformed);\n        },\n        (reject) => {\n          console.error('e05', reject);\n        }\n      )\n      .finally(() => {\n        // cache XHR requests so that same calls aren't made multiple times\n        remoteQueryCache[thumbprint] = true;\n        remoteResponseCache[thumbprint] = transformed || [];\n        fetchInProgress = false;\n        loader();\n        if (transformed.length && resultSet.query.length) {\n          calcSuggestions(transformed);\n          update();\n        }\n\n        // make another request if inputVal exists but is different than the last remote request\n        if (resultSet.query.length && frozenInput !== resultSet.query) {\n          fetchDataFromRemote();\n        }\n        noSuggestionsHandler(true);\n      });\n  };\n\n  /**\n   * Update the search Index with the keys\n   */\n  function updateSearchIndex(iterable: T[]) {\n    if (!iterable.length) return;\n\n    // add new items to the search index\n    for (const token of keys) {\n      trie.add(iterable, token, identity);\n    }\n  }\n\n  /**\n   * Sorts array in place giving preference to the starting letter of the query\n   */\n  const sortByStartingLetter = (suggestions: T[]): void => {\n    const query = resultSet.query.toLowerCase();\n    suggestions.sort((one: Dictionary, two: Dictionary) => {\n      const a = getNestedValue(one, keys[0]).toLowerCase();\n      const b = getNestedValue(two, keys[0]).toLowerCase();\n\n      const startsWithA = a.startsWith(query);\n      const startsWithB = b.startsWith(query);\n\n      if (startsWithA && startsWithB) {\n        // If both start with the given string, sort by shortest length first\n        return a.length - b.length;\n      }\n      if (startsWithA) {\n        // If only A starts with the given string, it should come first\n        return -1;\n      }\n      if (startsWithB) {\n        // If only B starts with the given string, it should come first\n        return 1;\n      }\n\n      // If neither start with the given string, maintain original order\n      return 0;\n    });\n  };\n\n  /**\n   * Sorts(in-place) array by group\n   */\n  const sortByGroup = (suggestions: T[]) => {\n    suggestions.sort((a: Dictionary, b: Dictionary) => {\n      const aVal = getNestedValue(a, groupKey);\n      const bVal = getNestedValue(b, groupKey);\n\n      // if no groupKey was found, do not sort\n      if (!aVal && !bVal) return 0;\n      if (!aVal) {\n        return -1;\n      }\n      if (!bVal) {\n        return 1;\n      }\n      // sort in ascending order of group name\n      if (aVal < bVal) {\n        return -1;\n      }\n      if (aVal > bVal) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  /**\n   * Highlights a given text by its pattern\n   * @param Elm The listContainer element\n   * @param pattern the string to highlight\n   */\n  const highlight = (Elm: HTMLElement, pattern: string): void => {\n    if (!pattern) return;\n\n    const getRegex = (query: string) => {\n      const escapedQueries = tokenizer(query.trim())\n        .map((item) => escapeRegExp(item))\n        .sort((a, b) => b.length - a.length); // sort by string length to correctly highlight words\n      // @deprecated [selection by words]\n      // const regexStr = wordsOnly ? '\\\\b(' + escapedQueries.join('|') + ')\\\\b' : '(' + escapedQueries.join('|') + ')';\n      return new RegExp(`(${escapedQueries.join('|')})`, 'i');\n    };\n\n    const regex = getRegex(pattern);\n\n    const highlightTextNode = (textNode: Text) => {\n      let match = regex.exec(textNode.data);\n\n      // Check for diacritics if necessary\n      if (config.diacritics && !match) {\n        match = regex.exec(diacritics(textNode.data));\n      }\n\n      if (match) {\n        const wrapperNode = document.createElement('span');\n        wrapperNode.className = classNames.highlight;\n\n        const patternNode = textNode.splitText(match.index);\n        patternNode.splitText(match[0].length);\n        wrapperNode.appendChild(patternNode.cloneNode(true));\n\n        textNode.parentNode?.replaceChild(wrapperNode, patternNode);\n        return true;\n      }\n      return false;\n    };\n\n    const traverse = (el: HTMLElement | ChildNode, highlightTextNode: (textNode: Text) => boolean) => {\n      const TEXT_NODE_TYPE = 3;\n      let childNode;\n\n      for (let i = 0; i < el.childNodes.length; i++) {\n        childNode = el.childNodes[i];\n\n        if (childNode.nodeType === TEXT_NODE_TYPE) {\n          i += highlightTextNode(childNode as Text) ? 1 : 0;\n        } else {\n          traverse(childNode, highlightTextNode);\n        }\n      }\n    };\n\n    traverse(Elm, highlightTextNode);\n  };\n\n  /**\n   * injects Hint input element into the DOM\n   * @param inputHint the input hint element\n   */\n  function injectHintEl(inputHint: HTMLInputElement) {\n    ['id', 'name', 'placeholder', 'required', 'aria-label'].forEach((attr) => inputHint.removeAttribute(attr));\n    inputHint.setAttribute('readonly', 'true');\n    inputHint.setAttribute('aria-hidden', 'true');\n    inputHint.style.marginTop = `-${input.offsetHeight + parseInt(computedInputStyle.marginBottom)}px`; // super-impose hint on input\n    inputHint.tabIndex = -1;\n    inputHint.className = classNames.hint;\n\n    input.after(inputHint);\n  }\n\n  /**\n   * Updates the value of hint\n   * @param selectedItem The selected item\n   */\n  const updateHint = (selectedItem: T) => {\n    const rawInput = input.value;\n\n    // if raw string is not part of suggestion, hide the hint\n    if (\n      !rawInput ||\n      display(selectedItem) === rawInput || // if input string is exactly the same as selectedItem\n      formatQuery(display(selectedItem)).indexOf(\n        formatQuery(rawInput)\n          .replace(/\\s{2,}/g, ' ')\n          .trimStart()\n      ) !== 0\n    ) {\n      inputHint.value = '';\n    } else {\n      const item = display(selectedItem);\n      const regex = new RegExp(escapeRegExp(resultSet.query), 'i');\n      let match = regex.exec(item);\n\n      // check for diacritics if necessary\n      if (config.diacritics && !match) {\n        match = regex.exec(diacritics(item));\n      }\n\n      if (match) {\n        inputHint.value = (rawInput.replace(/\\s?$/, '') + item.substring(match[0].length)) as string;\n      }\n    }\n  };\n\n  /**\n   * Creates and appends a template to an HTMLElement\n   * @param El The html element that the template should attach to\n   * @param templateHtml The raw string representation of the html template\n   */\n  const templatify = (El: HTMLElement | DocumentFragment, templateHtml: string) => {\n    const template = document.createElement('template');\n    template.innerHTML = templateHtml;\n    El.appendChild(template.content);\n    return templateHtml;\n  };\n\n  const blurEventHandler = (): void => {\n    // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n    setTimeout(() => {\n      if (document.activeElement !== input) {\n        clear();\n      }\n    }, 50);\n  };\n\n  /**\n   * Handle Long clicks\n   */\n  listContainer.addEventListener('mousedown', function (e: Event) {\n    e.stopPropagation();\n    e.preventDefault();\n  });\n\n  /**\n   * Resets the typeahead instance and clears everything\n   * Clears the search index as well as the entire cache\n   * clearLocalSrc?: boolean, if true, clears even the suggestions added via the Local Source\n   * */\n  const reset = (clearLocalSrc?: boolean) => {\n    clear();\n    trie.clear();\n    local && !clearLocalSrc && addToIndex(local);\n    remoteQueryCache = {};\n    remoteResponseCache = {};\n    if (prefetch) {\n      prefetch.done = false;\n    }\n  };\n\n  /**\n   * This function will remove DOM elements, clears cache and removes all event handlers\n   */\n  const destroy = (): void => {\n    clearRemoteDebounceTimer();\n    reset();\n    wrapper.replaceWith(input.cloneNode());\n  };\n\n  // setup event handlers\n  input.addEventListener('keydown', keydownEventHandler);\n  input.addEventListener('input', inputEventHandler as EventListenerOrEventListenerObject);\n  input.addEventListener('blur', blurEventHandler);\n  input.addEventListener('focus', focusEventHandler);\n\n  return {\n    addToIndex,\n    reset,\n    destroy,\n    // trie, // trie exposed only for local tests\n  };\n};\n\nexport default typeahead;"],"names":["NOOP","args","escapeRegExp","text","isObject","item","isString","getNestedValue","obj","selector","ref","keys","key","diacritics","txt","normalizer","listItems","spaceTokenizer","tokenString","get","url","requestOptions","response","handleResponse","data","fetchWrapper","Trie","config","hasDiacritics","tokenizer","root","SENTINEL","tokenize","value","add","identity","node","isStringArr","dataTokens","prefix","char","uniqueId","sentinelNode","find","matches","stack","k","results","resultKey","intersectDictionaries","dict1","dict2","result","search","query","limit","queryTokens","queryTokenLimit","suggestions","i","count","clear","listContainer","preventSubmit","minLen","hint","autoSelect","templates","groupKey","displayCb","display","onSubmit","transform","local","remoteUrlType","remote","prefetch","classNames","trie","wrapper","resultSet","remoteQueryCache","remoteResponseCache","selected","remoteDebounceTimer","fetchInProgress","storedInput","addToIndex","updateSearchIndex","input","computedInputStyle","parentEl","inputIndex","inputHint","injectHintEl","prefetchData","transformed","reject","show","hide","isListOpen","clearRemoteDebounceTimer","emitInputEvent","noSuggestionsHandler","asyncRender","clearListDOM","notFoundTemplateHtml","renderNotFoundTemplate","html","notFoundEl","templatify","loader","loaderEl","loaderDiv","update","render","itemElement","renderGroup","groupName","groupDiv","fragment","prevGroups","headerDiv","index","groupVal","div","ev","highlight","footerDiv","updateHint","element","rect","isAbove","isBelow","isLeft","isRight","inputEventHandler","startFetch","selectPrev","maxLength","selectNext","keydownEventHandler","useSelectedValue","fallback","focusEventHandler","val","emptyTemplateResp","emptyEl","calcSuggestions","thumbprint","fetchDataFromRemote","formatQuery","ip","newItems","uniqueItems","sortByStartingLetter","sortByGroup","frozenInput","iterable","token","one","two","a","b","startsWithA","startsWithB","aVal","bVal","Elm","pattern","regex","escapedQueries","highlightTextNode","textNode","match","wrapperNode","patternNode","traverse","el","childNode","attr","selectedItem","rawInput","El","templateHtml","template","blurEventHandler","reset","clearLocalSrc","destroy"],"mappings":"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"}